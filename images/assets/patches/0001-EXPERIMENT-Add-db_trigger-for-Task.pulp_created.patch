From d4c529757ae41e04e51b99c9263a261e690024e1 Mon Sep 17 00:00:00 2001
From: Matthias Dellweg <mdellweg@redhat.com>
Date: Fri, 6 Jun 2025 17:26:24 +0200
Subject: [PATCH] EXPERIMENT Add db_trigger for Task.pulp_created

---
 .../migrations/0133_task_insert_trigger.py    | 47 +++++++++++++++++++
 pulpcore/tasking/tasks.py                     | 30 ++----------
 2 files changed, 50 insertions(+), 27 deletions(-)
 create mode 100644 pulpcore/app/migrations/0133_task_insert_trigger.py

diff --git a/pulpcore/app/migrations/0133_task_insert_trigger.py b/pulpcore/app/migrations/0133_task_insert_trigger.py
new file mode 100644
index 000000000..ebd8261c6
--- /dev/null
+++ b/pulpcore/app/migrations/0133_task_insert_trigger.py
@@ -0,0 +1,47 @@
+# Generated by Django 4.2.22 on 2025-06-06 14:32
+
+from django.db import migrations
+
+# TODO: We need to think about a ZDU version of this change.
+
+
+TASK_INSERT_TRIGGER_UP = """
+CREATE FUNCTION on_insert_timestamp_task()
+  RETURNS TRIGGER
+  LANGUAGE plpgsql
+  AS $$
+    BEGIN
+      PERFORM pg_advisory_xact_lock(0, 21);  -- Same as TASK_DISPATCH_LOCK
+      NEW.pulp_created = clock_timestamp();
+      IF NEW.pulp_created <= (SELECT MAX(pulp_created) FROM core_task)
+      THEN
+        RAISE EXCEPTION 'Clock screw detected.';
+      END IF;
+      RETURN NEW;
+    END;
+  $$
+;
+
+CREATE TRIGGER on_insert_timestamp_task_trigger
+  BEFORE INSERT
+  ON core_task
+  FOR EACH ROW
+  EXECUTE FUNCTION on_insert_timestamp_task()
+;
+"""
+
+TASK_INSERT_TRIGGER_DOWN = """
+DROP TRIGGER on_insert_timestamp_task_trigger on core_task;
+DROP FUNCTION on_insert_timestamp_task;
+"""
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ("core", "0131_distribution_checkpoint_publication_checkpoint"),
+    ]
+
+    operations = [
+        migrations.RunSQL(sql=TASK_INSERT_TRIGGER_UP, reverse_sql=TASK_INSERT_TRIGGER_DOWN),
+    ]
diff --git a/pulpcore/tasking/tasks.py b/pulpcore/tasking/tasks.py
index fabe8f737..f80516792 100644
--- a/pulpcore/tasking/tasks.py
+++ b/pulpcore/tasking/tasks.py
@@ -9,12 +9,11 @@ import traceback
 import tempfile
 import threading
 from asgiref.sync import sync_to_async
-from datetime import timedelta
 from gettext import gettext as _
 
 from django.conf import settings
 from django.db import connection, transaction
-from django.db.models import Model, Max
+from django.db.models import Model
 from django_guid import get_guid
 from pulpcore.app.apps import MODULE_PLUGIN_VERSIONS
 from pulpcore.app.models import Task, TaskGroup
@@ -23,7 +22,6 @@ from pulpcore.constants import (
     TASK_FINAL_STATES,
     TASK_INCOMPLETE_STATES,
     TASK_STATES,
-    TASK_DISPATCH_LOCK,
     IMMEDIATE_TIMEOUT,
 )
 from pulpcore.tasking.kafka import send_task_notification
@@ -227,13 +225,6 @@ def dispatch(
     notify_workers = False
     with contextlib.ExitStack() as stack:
         with transaction.atomic():
-            # Task creation need to be serialized so that pulp_created will provide a stable order
-            # at every time. We specifically need to ensure that each task, when committed to the
-            # task table will be the newest with respect to `pulp_created`.
-            with connection.cursor() as cursor:
-                # Wait for exclusive access and release automatically after transaction.
-                cursor.execute("SELECT pg_advisory_xact_lock(%s, %s)", [0, TASK_DISPATCH_LOCK])
-            newest_created = Task.objects.aggregate(Max("pulp_created"))["pulp_created__max"]
             task = Task.objects.create(
                 state=TASK_STATES.WAITING,
                 logging_cid=(get_guid()),
@@ -247,28 +238,13 @@ def dispatch(
                 immediate=immediate,
                 deferred=deferred,
             )
-            if newest_created and task.pulp_created <= newest_created:
-                # Let this workaround not row forever into the future.
-                if newest_created - task.pulp_created > timedelta(seconds=1):
-                    # Do not commit the transaction if this condition is not met.
-                    # If we ever hit this, think about delegating the timestamping to PostgresQL.
-                    raise RuntimeError("Clockscrew detected. Task dispatching would be dangerous.")
-                # Try to work around the smaller glitch
-                task.pulp_created = newest_created + timedelta(milliseconds=1)
-                task.save()
-            if task_group:
-                task_group.refresh_from_db()
-                if task_group.all_tasks_dispatched:
-                    task.set_canceling()
-                    task.set_canceled(
-                        TASK_STATES.CANCELED, "All tasks in group have been dispatched/canceled."
-                    )
-                    return task
             if immediate:
                 # Grab the advisory lock before the task hits the db.
                 stack.enter_context(task)
             else:
                 notify_workers = True
+        # Since the db sets the pulp_created field for us we cannot rely on what django thinks.
+        del task.pulp_created
         if immediate:
             prior_tasks = Task.objects.filter(
                 state__in=TASK_INCOMPLETE_STATES, pulp_created__lt=task.pulp_created
-- 
2.49.0

