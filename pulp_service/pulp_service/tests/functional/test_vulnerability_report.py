import json
import pytest

from tempfile import NamedTemporaryFile
from jsonschema import validate

from pulp_service.tests.functional.constants import (
    GEM_REMOTE_INCLUDE,
    GEM_REMOTE_REGISTRY,
    NPM_PACKAGE_LOCK_FILE,
    NPM_REMOTE_REGISTRY,
    NPM_SAMPLE_PACKAGE,
    OSV_SCHEMA,
    PYTHON_REMOTE_REPO,
    PYTHON_REMOTE_INCLUDE,
)


@pytest.fixture
def check_osv_schema():
    """Fixture to verify if the vuln report model is in compliance with osv-schema"""

    def _check_osv_schema(report):
        for package in report.vulns.values():
            for vulns in package:
                validate(instance=vulns, schema=OSV_SCHEMA)

    return _check_osv_schema


@pytest.fixture
def run_vuln_report(add_to_cleanup, monitor_task, vuln_report_api):
    """Fixture to make a request to vuln report endpoint"""

    def _run_vuln_report(package_json=None, repo_version=None):
        report_response = vuln_report_api.create(
            package_json=package_json, repo_version=repo_version
        )
        task = monitor_task(report_response.task)
        vuln_report_href = task.created_resources[0]
        add_to_cleanup(vuln_report_api, vuln_report_href)
        return vuln_report_href

    return _run_vuln_report


@pytest.fixture
def vuln_report_checks(check_osv_schema, vuln_report_api):
    def _vuln_report_checks(vuln_report_href):
        """Vulnerability Report checks"""
        # verify retrieve method by checking if vulns dict is not empty
        report = vuln_report_api.read(service_vulnerability_report_href=vuln_report_href)
        assert report.vulns

        # verify model integrity by checking if it follows osv schema
        check_osv_schema(report)

        # verify list method
        report_list = vuln_report_api.list()
        assert report_list.count > 0

        # verify delete
        vuln_report_api.delete(service_vulnerability_report_href=vuln_report_href)
        assert vuln_report_api.list().count == 0

    return _vuln_report_checks


def test_npm_package_lock(run_vuln_report, vuln_report_checks):
    """Test the vuln_report endpoint passing a NPM package_json file"""
    report = None
    with NamedTemporaryFile(mode="wb") as lock_file:
        lock_file.write(json.dumps(NPM_PACKAGE_LOCK_FILE).encode("utf-8"))
        lock_file.flush()
        report = run_vuln_report(package_json=lock_file.name)
    vuln_report_checks(report)


@pytest.mark.parametrize(
    "bindings, repo_binding_api, repo_href_arg_name, repo_factory,remote_factory,remote_url,remote_includes",
    [
        (
            "python_bindings",
            "RepositoriesPythonApi",
            "python_python_repository_href",
            "python_repo_factory",
            "python_remote_factory",
            PYTHON_REMOTE_REPO,
            PYTHON_REMOTE_INCLUDE,
        ),
        (
            "npm_bindings",
            "RepositoriesNpmApi",
            "npm_npm_repository_href",
            "npm_repository_factory",
            "npm_remote_factory",
            NPM_REMOTE_REGISTRY + NPM_SAMPLE_PACKAGE,
            None,
        ),
        (
            "gem_bindings",
            "RepositoriesGemApi",
            "gem_gem_repository_href",
            "gem_repository_factory",
            "gem_remote_factory",
            GEM_REMOTE_REGISTRY,
            GEM_REMOTE_INCLUDE,
        ),
    ],
)
def test_repo_version_vuln_report(
    monitor_task,
    request,
    bindings,
    repo_binding_api,
    repo_href_arg_name,
    repo_factory,
    remote_factory,
    remote_url,
    remote_includes,
    run_vuln_report,
    vuln_report_checks,
):
    """Test the vuln_report endpoint for repo_version parameter"""

    # "Cast/Convert" the pytest parameters into "real" fixtures
    bindings = request.getfixturevalue(bindings)
    repo_factory = request.getfixturevalue(repo_factory)
    remote_factory = request.getfixturevalue(remote_factory)

    # Get the Binding API
    repo_binding_api = getattr(bindings, repo_binding_api)

    remote_params = {"url": remote_url}
    if remote_includes:
        remote_params["includes"] = remote_includes
    remote = remote_factory(**remote_params)
    repo = repo_factory(remote=remote.pulp_href)
    monitor_task(repo_binding_api.sync(repo.pulp_href, {}).task)

    latest_repo_version = repo_binding_api.read(
        **{
            repo_href_arg_name: repo.pulp_href
        },  # unpacks the dict into kwargs for the function call
    ).latest_version_href

    report = run_vuln_report(repo_version=latest_repo_version)
    vuln_report_checks(report)
