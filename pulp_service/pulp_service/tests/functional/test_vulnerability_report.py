import json
import pytest

from tempfile import NamedTemporaryFile
from jsonschema import validate

from pulpcore.client.pulp_rpm import ContentPackagesApi
from pulp_service.app.constants import OSV_RH_ECOSYSTEM_LABEL, OSV_RH_ECOSYSTEM_CPES_LABEL
from pulp_service.tests.functional.constants import (
    GEM_REMOTE_INCLUDE,
    GEM_REMOTE_REGISTRY,
    GEM_VULNERABILITY_IDS,
    GEM_VULNERABILITY_PACKAGE,
    NPM_PACKAGE_LOCK_FILE,
    NPM_REMOTE_REGISTRY,
    NPM_SAMPLE_PACKAGE,
    NPM_VULNERABILITY_IDS,
    NPM_VULNERABILITY_PACKAGE,
    OSV_SCHEMA,
    PYTHON_REMOTE_REPO,
    PYTHON_REMOTE_INCLUDE,
    PYTHON_VULNERABILITY_IDS,
    PYTHON_VULNERABILITY_PACKAGE,
    RPM_SAMPLE_PACKAGE_URL,
    RPM_SAMPLE_RH_CPE,
    RPM_VULNERABILITY_IDS,
    RPM_VULNERABILITY_PACKAGE,
)


@pytest.fixture
def check_osv_schema():
    """Fixture to verify if the vuln report model is in compliance with osv-schema"""

    def _check_osv_schema(report):
        for package in report.vulns.values():
            for vulns in package:
                validate(instance=vulns, schema=OSV_SCHEMA)

    return _check_osv_schema


@pytest.fixture
def run_vuln_report(add_to_cleanup, monitor_task, vuln_report_api):
    """Fixture to make a request to vuln report endpoint"""

    def _run_vuln_report(package_json=None, repo_version=None):
        report_response = vuln_report_api.create(
            package_json=package_json, repo_version=repo_version
        )
        task = monitor_task(report_response.task)
        vuln_report_href = task.created_resources[0]
        add_to_cleanup(vuln_report_api, vuln_report_href)
        return vuln_report_href

    return _run_vuln_report


@pytest.fixture
def vuln_report_checks(check_osv_schema, vuln_report_api):
    def _vuln_report_checks(vuln_report_href):
        """Vulnerability Report checks"""
        # verify retrieve method by checking if vulns dict is not empty
        report = vuln_report_api.read(service_vulnerability_report_href=vuln_report_href)

        # verify model integrity by checking if it follows osv schema
        check_osv_schema(report)

        # verify list method
        report_list = vuln_report_api.list()
        assert report_list.count > 0

        # verify delete
        vuln_report_api.delete(service_vulnerability_report_href=vuln_report_href)
        assert vuln_report_api.list().count == 0
        return report

    return _vuln_report_checks


def test_npm_package_lock(run_vuln_report, vuln_report_checks):
    """Test the vuln_report endpoint passing a NPM package_json file"""
    report = None
    with NamedTemporaryFile(mode="wb") as lock_file:
        lock_file.write(json.dumps(NPM_PACKAGE_LOCK_FILE).encode("utf-8"))
        lock_file.flush()
        report_href = run_vuln_report(package_json=lock_file.name)
    report = vuln_report_checks(report_href)

    # verify if the report contains known vulnerabilities
    vuln_ids = [vuln["id"] for vuln in report.vulns[NPM_VULNERABILITY_PACKAGE]]
    assert set(NPM_VULNERABILITY_IDS).issubset(vuln_ids)


@pytest.mark.parametrize(
    "bindings, repo_binding_api, repo_href_arg_name, repo_factory, remote_factory, remote_url, remote_includes, expected_vuln_pkg_name, expected_vuln_ids",
    [
        (
            "python_bindings",
            "RepositoriesPythonApi",
            "python_python_repository_href",
            "python_repo_factory",
            "python_remote_factory",
            PYTHON_REMOTE_REPO,
            PYTHON_REMOTE_INCLUDE,
            PYTHON_VULNERABILITY_PACKAGE,
            PYTHON_VULNERABILITY_IDS,
        ),
        (
            "npm_bindings",
            "RepositoriesNpmApi",
            "npm_npm_repository_href",
            "npm_repository_factory",
            "npm_remote_factory",
            NPM_REMOTE_REGISTRY + NPM_SAMPLE_PACKAGE,
            None,
            NPM_VULNERABILITY_PACKAGE,
            NPM_VULNERABILITY_IDS,
        ),
        (
            "gem_bindings",
            "RepositoriesGemApi",
            "gem_gem_repository_href",
            "gem_repository_factory",
            "gem_remote_factory",
            GEM_REMOTE_REGISTRY,
            GEM_REMOTE_INCLUDE,
            GEM_VULNERABILITY_PACKAGE,
            GEM_VULNERABILITY_IDS,
        ),
    ],
)
def test_repo_version_vuln_report(
    monitor_task,
    request,
    bindings,
    repo_binding_api,
    repo_href_arg_name,
    repo_factory,
    remote_factory,
    remote_url,
    remote_includes,
    expected_vuln_pkg_name,
    expected_vuln_ids,
    run_vuln_report,
    vuln_report_checks,
):
    """Test the vuln_report endpoint for repo_version parameter"""

    # "Cast/Convert" the pytest parameters into "real" fixtures
    bindings = request.getfixturevalue(bindings)
    repo_factory = request.getfixturevalue(repo_factory)
    remote_factory = request.getfixturevalue(remote_factory)

    repo_binding_api = getattr(bindings, repo_binding_api)

    remote_params = {"url": remote_url}
    if remote_includes:
        remote_params["includes"] = remote_includes
    remote = remote_factory(**remote_params)
    repo = repo_factory(remote=remote.pulp_href)
    monitor_task(repo_binding_api.sync(repo.pulp_href, {}).task)

    latest_repo_version = repo_binding_api.read(
        **{
            repo_href_arg_name: repo.pulp_href
        },  # unpacks the dict into kwargs for the function call
    ).latest_version_href

    report_href = run_vuln_report(repo_version=latest_repo_version)
    report = vuln_report_checks(report_href)

    # verify if the report contains known vulnerabilities
    vuln_ids = [vuln["id"] for vuln in report.vulns[expected_vuln_pkg_name]]
    assert set(expected_vuln_ids).issubset(vuln_ids)


# defining a specific test for RPM because the plugin has no support to filter packages during sync,
# which would make the tests running for a long time until sync finishes
def test_rpm__repo_version_vuln_report(
    monitor_task,
    rpm_client,
    rpm_repository_api,
    rpm_repository_factory,
    run_vuln_report,
    vuln_report_checks,
):
    """Test the vuln_report endpoint for RPM repo_version parameter"""
    repository = rpm_repository_factory(
        pulp_domain="default",
        pulp_labels={
            OSV_RH_ECOSYSTEM_LABEL: "Red Hat",
            OSV_RH_ECOSYSTEM_CPES_LABEL: RPM_SAMPLE_RH_CPE,
        },
    )

    content_package_api = ContentPackagesApi(rpm_client)
    monitor_task(
        content_package_api.create(
            file_url=RPM_SAMPLE_PACKAGE_URL,
            repository=repository.pulp_href,
        ).task
    )

    latest_repo_version = rpm_repository_api.read(
        rpm_rpm_repository_href=repository.pulp_href
    ).latest_version_href
    report_href = run_vuln_report(repo_version=latest_repo_version)
    report = vuln_report_checks(report_href)

    # verify if the report contains known vulnerabilities
    vuln_ids = [vuln["id"] for vuln in report.vulns[RPM_VULNERABILITY_PACKAGE]]
    assert set(RPM_VULNERABILITY_IDS).issubset(vuln_ids)
